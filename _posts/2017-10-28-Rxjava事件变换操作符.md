在Rxjava中通过Map操作符将一个Observable装换成另外一个Observable.用官方的一张图可以很直观的看出它的效果:

![](http://reactivex.io/documentation/operators/images/map.png)

```java
public final <R> Observable<R> map(Func1<? super T, ? extends R> func) {
        return create(new OnSubscribeMap<T, R>(this, func));
}
```

从代码可以看到map函数接收一个Func1类型的参数,这个Func1和Action1类似也是一个接口,提供一个call函数,Func1有两个泛型,我们可以把T理解为源事件流,R为目标结果事件流.call函数用来将T转换为R.

```java
public interface Func1<T, R> extends Function {
    R call(T t);
}
```

还是从一个简单的例子来跟踪源码:

```java

        Observable<String> origin = Observable.just("HuChengzhi");

        Observable<User> mapObs = origin.map(new Func1<String, User>() {
            @Override
            public User call(String s) {
                return new User("1", s, "Null");
            }
        });

        mapObs.subscribe(new Subscriber<User>() {
            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(User user) {
                Log.i(TAG,"user: "+user.getName());
            }
        });
```

这里没有用链式是因为想一步一步的分析代码.首先Observable.just创建了一个原始的数据流**origin**,然后通过map函数将**origin**转换成新的数据流**mapObs**,map通过create函数返回一个新的Observable,在[Rxjava机制简单分析](https://jsonhu.github.io/2017/10/Rxjava%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/)中说过,create函数会将形参赋值给Observable的全局变量OnSubscribe,同样在这里OnSubscribeMap也是实现自OnSubscribe接口.在OnSubscribeMap的构造器中接收this和Func1,这个this和origin指向了同一个数据流对象.当mapObs触发了订阅事件之后,