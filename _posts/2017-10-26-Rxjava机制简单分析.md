最近有点时间来简单研究一下Rxjava原理，Rxjava基于传统的观察者模式，同样的在Rxjava观察者模式中有两个重要的角色：Observable（被观察者）、Observer（观察者）。当被观察者的数据或者状态发生改变的时候，会及时的告知观察者，而这个告知的过程就是一个订阅关系，在Rxjava中，Observable中提供subscribe方法来实现Observable和Observe的订阅关系。
Observer是一个接口，它提供了三个函数onComplete、onError、onNext。
- onComplete表示整个事件队列完结
- onError表示在事件队列处理的过程中发生了异常，并且在Observer的定义中，onComplete和onError是互斥，两者只会在同一时间调用一次
- onNext为观察者提供需要处理的事件

在平时Rxjava的使用中，我们通常不会直接去new这个Observer，而是使用它实现类Subscriber，从它的名字一目了然表示订阅者，即需要知道最终结果的那个角色。在Subscriber类定义中，它不仅实现了Observer接口，还实现了Subscription接口，它可以用来取消订阅关系，终止事件发送。

既然订阅者需要去订阅某一个事件，那这个事件是如何创建出来的？这个事件的创建是由Observeable（被观察者）创建的，它来处理这个事件整个过程最终将结果回调给Subscriber。

所以可以看出在整个Rxjava中有这么四个角色：Observable、Subscriber、subscribe（订阅关系）、事件。

通过简单的事例来了解这个过程：
```java
Observable.create(new Observable.OnSubscribe<String>() {
            @Override
            public void call(Subscriber<? super String> subscriber) {
                StringBuilder builder = new StringBuilder();
                builder.append("Rx");
                builder.append("Java");

                subscriber.onNext(builder.toString());
                subscriber.onCompleted();
            }
        }).subscribe(new Subscriber<String>() {
            @Override
            public void onCompleted() {
                Log.i("TAG","onCompleted");
            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(String s) {
                Log.i("TAG","==> "+s);
            }
        });
```
这是一个简单的用例，这里没有涉及到线程切换、事件变换等复杂的使用。从代码中看到，Observable中提供了一个create函数：
```java
    public static <T> Observable<T> create(OnSubscribe<T> f) {
        return new Observable<T>(RxJavaHooks.onCreate(f));
    }
```
在create的函数中接受一个OnSubscribe对象，这个OnSubscribe是定义在Observable中的一个接口：
```java
    public interface OnSubscribe<T> extends Action1<Subscriber<? super T>> {
        // cover for generics insanity
    }
```
继承了Action1，在Action1申明了一个函数call，call函数接受一个泛型T
```java
public interface Action1<T> extends Action {
    void call(T t);
}
```
OnSubscribe指定了Action1中的泛型为Subscriber，所以call函数会接受一个Subscriber，那么这个Subscriber是怎么传递进来的，接着上面的事例继续跟踪源码，刚刚说到create函数里传递进来一个OnSubscribe对象，并且将这个对象作为参数传递到Observable的构造器中，在Observable的构造器中只做了一件事情：
```java
protected Observable(OnSubscribe<T> f) {
        this.onSubscribe = f;
 }
```
将外部new出来的OnSubscribe对象赋值给全局变量，至此准备工作已经做完了，在这里我觉得可以把OnSubscribe的call函数理解为被观察者要处理的事件，等到事件处理完之后需要将结果回调给Subscriber，所以在call函数中我们需要接受这一个Subscriber，调用它的onNext、onComplete、或者onError。
那么整个订阅的事件过程是通过subscribe函数展开的：
```java
    public final Subscription subscribe(Subscriber<? super T> subscriber) {
        return Observable.subscribe(subscriber, this);
    }

    static <T> Subscription subscribe(Subscriber<? super T> subscriber, Observable<T> observable) {
     // validate and proceed
        if (subscriber == null) {
            throw new IllegalArgumentException("subscriber can not be null");
        }
        if (observable.onSubscribe == null) {
            throw new IllegalStateException("onSubscribe function can not be null.");
            /*
             * the subscribe function can also be overridden but generally that's not the appropriate approach
             * so I won't mention that in the exception
             */
        }

        // new Subscriber so onStart it
        subscriber.onStart();

        /*
         * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls
         * to user code from within an Observer"
         */
        // if not already wrapped
        if (!(subscriber instanceof SafeSubscriber)) {
            // assign to `observer` so we return the protected version
            subscriber = new SafeSubscriber<T>(subscriber);
        }

        // The code below is exactly the same an unsafeSubscribe but not used because it would
        // add a significant depth to already huge call stacks.
        try {
            // allow the hook to intercept and/or decorate
            RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);
            return RxJavaHooks.onObservableReturn(subscriber);
        } catch (Throwable e) {
            ...
        }
    }
```
在订阅关系中我们需要指明一个订阅者Subscriber，接着调用了Observable中的静态subscribe方法，在所有事件发送之前，它先调用了subscriber的onStart方法，用于做一些准备工作，然后对subscriber进行一次包装，跳过RxJavaHook的操作，先不去了解它的作用，最后可以看到它调用了Observable中之前赋值的全局变量OnSubscribe的call方法，并且将最后包装的subscriber传递进去，所以在上面的用例代码中，call函数创建一个新的String然后将这个结果通过subscriber的onNext传递过去即表示我们想要的最终结果。这个过程简单不复杂，我觉得先弄清楚基本的流程在去深入是个比较好的方法，只是我自己的见解，因为从一开始直接上来了解复杂的操作符和线程调度，会看的云里雨雾的。
