# Activity组件的启动过程

>想得再多不如动手去做,让事实来证明对与错

### 从桌面Launcher点击应用图标发生了什么

Android桌面应用程序也Launcher是一个Activity,在Launcher上会罗列着各种各样的App图标,那么当我们点击某一个App的图标进入到应用程序的这个过程中发生了什么呢?

在Android开发中,每个应用程序都有一个入口,暂且称之为MainActivity.从Launcher到MainActivity的跳转是由一个AMS(ActivityManagerService)来控制的,它是一个系统服务,是所有Activity的大管家,和Launcher以及MainActivity都处于不同的进程,每一个Activity的生命周期都是由AMS来控制的,所以从Launcher跳转到MainActivity,需要告知AMS,由它来管理哪个Activity需要resume,哪个Activity需要pause,这个过程属于跨进程通信,Android内部提供Binder机制由Binder驱动来完成各个进程之间的通信,在操作系统中,进程间的通信有很多种,为何选择了Binder,是否思考过它的优点在哪里?

通过上面的描述我们知道当用户在桌面点击App图标进入到应用内部,这中间有三个重要的角色:AMS Launcher MainActivity.

### 从Launcher3的源码了解用户点击图标做了什么

Launcher3的源码地址https://android.googlesource.com/platform/packages/apps/Launcher3/+/master/src/com/android/launcher3/Launcher.java

通过搜索onClick来寻找整个流程的起源:

```java
public class Launcher extends BaseActivity implements View.OnClickListener, OnLongClickListener{
    
 /**
  * 1.顾名思义,ShortCut表示快捷方式,也就是咱们的应用图标了
  */
  public void onClick(View v) {
        ...
        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            onClickAppShortcut(v);
        } 
        ...
  }
  
  /**
  * 2.已经找到启动Activity的入口函数了 startActivitySafely
  */
  protected void onClickAppShortcut(final View v) {
        if (LOGD) Log.d(TAG, "onClickAppShortcut");
        Object tag = v.getTag();
       	....
        // Start activities
        startAppShortcutOrInfoActivity(v);
  }
  
  private void startAppShortcutOrInfoActivity(View v) {
        ItemInfo item = (ItemInfo) v.getTag();
        Intent intent = item.getIntent();
        if (intent == null) {
            throw new IllegalArgumentException("Input must have a valid intent");
        }
        boolean success = startActivitySafely(v, intent, item);
    }
}
```

在startActivitySafely最终调用了父类Activity的startActivity继而是startActivityForResult方法:

```java
	
  public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
            @Nullable Bundle options) {
        if (mParent == null) {
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
            if (ar != null) {
                mMainThread.sendActivityResult(
                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                    ar.getResultData());
            }
          
        } 
 }
```

在这段代码里Activity将启动目标组件的任务交给了Instrumentation,在Instrumentation的注释中了解到它在Application之前就已经初始化好了,是用来检测所有应用程序和系统之间的交互的

>When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application. 

execStartAcitivity中mMainThread代表ActivityThread对象,ActivityThread在应用程序进程启动的时候已经实例化好了,也是整个程序的入口,mMainThread.getApplicationThread()获取的是ActivityThread的内部类ApplicationThread,它负责和AMS通信.



