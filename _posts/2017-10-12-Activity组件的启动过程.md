# Activity组件的启动过程

>想得再多不如动手去做,让事实来证明对与错

### 从桌面Launcher点击应用图标发生了什么

Android桌面应用程序也Launcher是一个Activity,在Launcher上会罗列着各种各样的App图标,那么当我们点击某一个App的图标进入到应用程序的这个过程中发生了什么呢?

在Android开发中,每个应用程序都有一个入口,暂且称之为MainActivity.从Launcher到MainActivity的跳转是由一个AMS(ActivityManagerService)来控制的,它是一个系统服务,是所有Activity的大管家,和Launcher以及MainActivity都处于不同的进程,每一个Activity的生命周期都是由AMS来控制的,所以从Launcher跳转到MainActivity,需要告知AMS,由它来管理哪个Activity需要resume,哪个Activity需要pause,这个过程属于跨进程通信,Android内部提供Binder机制由Binder驱动来完成各个进程之间的通信,在操作系统中,进程间的通信有很多种,为何选择了Binder,是否思考过它的优点在哪里?

通过上面的描述我们知道当用户在桌面点击App图标进入到应用内部,这中间有三个重要的角色:AMS Launcher MainActivity.

### 从Launcher3的源码了解用户点击图标做了什么

Launcher3的源码地址https://android.googlesource.com/platform/packages/apps/Launcher3/+/master/src/com/android/launcher3/Launcher.java

通过搜索onClick来寻找整个流程的起源:

```java
public class Launcher extends BaseActivity implements View.OnClickListener, OnLongClickListener{
    
 /**
  * 1.顾名思义,ShortCut表示快捷方式,也就是咱们的应用图标了
  */
  public void onClick(View v) {
        ...
        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            onClickAppShortcut(v);
        } 
        ...
  }
  
  /**
  * 2.已经找到启动Activity的入口函数了 startActivitySafely
  */
  protected void onClickAppShortcut(final View v) {
        if (LOGD) Log.d(TAG, "onClickAppShortcut");
        Object tag = v.getTag();
       	....
        // Start activities
        startAppShortcutOrInfoActivity(v);
  }
  
  private void startAppShortcutOrInfoActivity(View v) {
        ItemInfo item = (ItemInfo) v.getTag();
        Intent intent = item.getIntent();
        if (intent == null) {
            throw new IllegalArgumentException("Input must have a valid intent");
        }
        boolean success = startActivitySafely(v, intent, item);
    }
}
```

在startActivitySafely最终调用了父类Activity的startActivity继而是startActivityForResult方法:

```java
	
  public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
            @Nullable Bundle options) {
        if (mParent == null) {
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
            if (ar != null) {
                mMainThread.sendActivityResult(
                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                    ar.getResultData());
            }
          
        } 
 }
```

在这段代码里Activity将启动目标组件的任务交给了Instrumentation,在Instrumentation的注释中了解到它在Application之前就已经初始化好了,是用来检测所有应用程序和系统之间的交互的

>When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application. 

execStartAcitivity中mMainThread代表ActivityThread对象,ActivityThread在应用程序进程启动的时候已经实例化好了,也是整个程序的入口,mMainThread.getApplicationThread()获取的是ActivityThread的内部类ApplicationThread,它负责和AMS通信.token它表示当前Activity在远程对应的ActivityRecord的标识,每个已经启动了的Activity都会对应一个ActivityRecord来记录它的信息.进入到Instrumentation的execStartActivity的方法:

> 这个token怎么解释?

```java
 public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
        IApplicationThread whoThread = (IApplicationThread) contextThread;
        try {
            int result = ActivityManager.getService()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
        } catch (RemoteException e) {
            throw new RuntimeException("Failure from system", e);
        }
        return null;
    }
```

这里通过Binder IPC调用了系统服务-AMS的startActivity()方法:

```java
@Override
  public final int startActivity(IApplicationThread caller, String callingPackage,
           Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions,
                UserHandle.getCallingUserId());
    }

@Override
    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int 	requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
        // TODO: Switch to user app stacks here.
        return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,
                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
                profilerInfo, null, null, options, userId, null, null);
    }
```

在startActivityAsUser里,早一点的版本里直接调用了mMainStack的startActivityMayWait的方法,在最新的8.0中,多出来个新的类ActivityStarter,可否将它翻译为Activity启动器?不妨看一下ActivityStarter的官方解释:

> Controller for interpreting how and then launching activities,This class collects all the logic for determining how an intent and flags should be turned into an activity and associated task and stack

意思就是说它是一个用来解释如何启动Activity的控制器,这个类聚集了所有如何将intent和flag转换到对应的Activity和与之关联的任务栈的逻辑. 我去除掉了startActivityMayWait不太重要的代码提取出启动Activity的关键代码如下:

```java
final int startActivityMayWait(IApplicationThread caller, int callingUid,
            String callingPackage, Intent intent, String resolvedType,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int startFlags,
            ProfilerInfo profilerInfo, WaitResult outResult,
            Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId,
            IActivityContainer iContainer, TaskRecord inTask, String reason) {

        // Don't modify the client's object!
        intent = new Intent(intent);
	
  		ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);

        ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);
        synchronized (mService) {
            int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                    aInfo, rInfo, voiceSession, voiceInteractor,
                    resultTo, resultWho, requestCode, callingPid,
                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                    options, ignoreTargetSecurity, componentSpecified, outRecord, container,
                    inTask, reason);

     
            return res;
        }
 }
```

##### frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java

```java
 ResolveInfo resolveIntent(Intent intent, String resolvedType, int userId, int flags) {
        synchronized (mService) {
            return mService.getPackageManagerInternalLocked().resolveIntent(intent, resolvedType,
                    PackageManager.MATCH_INSTANT | PackageManager.MATCH_DEFAULT_ONLY | flags
                    | ActivityManagerService.STOCK_PM_FLAGS, userId);
        }
  }
```

这里ActivityStarter做了两件事情第一就是讲客户端(分析到这里已经是在系统服务了ActivityManagerService)传递进来的intent保留copy一个副本,将这个副本intent包含的信息通过ActivityStackSupervisor解析出来,解析intent的操作调用了PackageManagerService包管理器服务中的方法,第二将第一步解析出来的ActivityInfo已参数的形式传递给startActivityLocked方法:

##### frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java

```java
int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
           String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
            TaskRecord inTask, String reason) {

        mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,
                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,
                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,
                container, inTask);
    }
```

它只是调用了自己的私有函数startActivity,并且这个方法还有个声明,此方法不能直接调用必须在startActivityLocked中调用:

```java

```





