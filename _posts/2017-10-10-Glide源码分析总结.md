从去年开始一直在使用Glide来加载图片，但是一直没有空闲时间来总结Glide是如何加载图片的。

参考自：[ Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程](http://blog.csdn.net/guolin_blog/article/details/53939176)

本文用作自己学习框架整理的文章。

从下面的代码开始分析：
```java
Glide.with(context).load(String).with(imageview);
```
这短短一行的代码背后做了很多复杂的事情，从with开始跟踪他做了哪些事情,相比于Picasso，Glide的with函数可以接受多个不同类型的参数，可以传递context，Activity，fragment，这样Glide下载图片的请求可以和组件的生命周期相关联，这样Glide可以帮助我们自行的去管理请求，什么时候可以取消掉。

```java
   /**
     * Begin a load with Glide that will be tied to the given {@link android.app.Activity}'s lifecycle and that uses the
     * given {@link Activity}'s default options.
     *
     * @param activity The activity to use.
     * @return A RequestManager for the given activity that can be used to start a load.
     */
    public static RequestManager with(Activity activity) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(activity);
    }

```
我们随便选一个以Activity作为参数的with方法，先看它的注释说明，Glide开始一个加载请求，这个请求将会和给定的Activity的生命周期绑定在一起，在with方法里，通过**RequestManagerRetriever.get()**来获取到一个**RequestManager**，跟着代码继续进入到RequestManagerRetriever中，看看get是如何获取的：
```java


    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public RequestManager get(Activity activity) {
        if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
            return get(activity.getApplicationContext());
        } else {
            assertNotDestroyed(activity);
            android.app.FragmentManager fm = activity.getFragmentManager();
            return fragmentGet(activity, fm);
        }
    }

```

