算法：

1 标记清除算法（Mark-Sweep）：

​     分为“标记”和“清除”两个过程：标记出所有需要被回收的对象，标记完成之后统一回收，标记的过程从一个叫“GcRoot”的根节点开始，来查找到回收对象之间是否有可达的路径。

​     缺点：一是效率问题，二是回收之后内存碎片化的问题，如果在此过程中需要分配大对象时，如果找不到一块连续足够大的内存，那么将再一次触发GC

2 复制算法（Copy）：

​     将内存按比例划分为两块，每次使用其中的一块，如果这一块内存用完触发GC的时候，会将存活下来的对象全部拷贝到另一片中，然后一次性清除原先的那块内存，拷贝的时候按顺序分配内存即可，移动堆顶指针就可以，这样就避免了内存碎片。因为新生代的对象存活率很低，所以这两块区域的比例不一定要按照1:1分配，而是将新生代分为一块较大的Eden和两块较小的Survivor空间，每次分配内存使用Eden和其中的一个Survivor，当再次分配对象的时候如果在这两片空间内找不到足够大连续的内存，那么触发GC之后，在Eden和第一个Survivor中存活的对象copy到另外一个Survivor中 

![](http://www.memorymanagement.org/_images/copying.svg)



​     复制算法在对象存活率较高的时候进行多次复制操作效率会变低，所以YoungGeneration大都会采用复制算法。

3 标记整理算法（Mark-Compact）：

​     过程与标记清除一样，但他并不是对可回收对象直接清理，而是让存活的对象都向一端移动，然后清理掉端边界以外的内存

4 分代收集算法：

​     Java将堆分为新生代和老年代，新生代采用复制算法，老年代采用标记清除或者标记整理算法。

分配和回收策略：

1  对象优先在Eden分配

2  大对象直接进入老年代：大对象指需要大量连续内存空间的对象，比如很长的字符串和数组，将他们放置在老年代空间主要是为了放置Eden和两个Survivor发生大量的复制操作。

3  长期存活的对象进入老年代：虚拟机给对象定义一个Age计数器，如果对象在Eden中经过第一次Minor GC后仍然存活并且能够被Survivor容纳，那么这个对象会被移动到Survivor区域中并且年龄设为1岁，之后这个对象在Survivor中每经经历过一次Minor GC存活下来年龄就会增加1岁，当年龄增加到一定程度这个对象就会被晋升到老年代中

4  动态对象年龄判定：虚拟机并非强制性要求Survivor中的对象年龄达到某一个阈值才能晋升到老年代中，如果在Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代中

5  空间分配担保：在发生Minor GC之前，虚拟机会先检查老年代中最大可用的连续空间是否大于新生代所有对象的总和，如果大于，那么Minor GC是安全的，否则虚拟机会检查HandlePromotionFailure这个值是否允许担保失败，如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试一次Minor GC，如果小于或者不允许担保失败，那么将会触发一个Full GC。